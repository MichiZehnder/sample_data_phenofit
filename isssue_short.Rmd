---
title: "Phenofit issue"
author: "Michael Zehnder"
date: "2023-11-23"
output: html_document
---



I have data on vegetation height for several years. I want to use `get_pheno()` (using an Elmore function) to extract the start of season in every year. I am not very much interested in senescence. My data only allows to work with phenological dates at the beginning of the season. 

Phenofit's `curvefit()` and `get_pheno(..., isPlot=TRUE)` plots nicely fitted curves on my input data. My issues is that if I parametrize the growth curves myself in ggplot using the Elmore function with the parameters from `get_param()`, I do not get the same curves as in the "autoplot" output of `get_pheno(..., isPlot=TRUE)`. In fact, some `mx` values derived from `get_params()` are clearly too high (indeed higher than the fine-fitted curves in `get_pheno(..., isPlot=TRUE)`) and my own curves completely overshoot the input data points. Since the phenological dates of interest (start of season) is also part of the parametrization of the curve, this date is not correct and does not align with the input data. At the same time, the autoplot function `get_pheno(..., isPlot=TRUE)` (from which the curve parametrization is derived!) fits the curves smoothly to the input data points. So now, I am unsure if the phenological dates that I continue working with are correct or not. And I am wondering how exactly the curves in `get_pheno(..., isPlot=TRUE)` are created.
  
Here is, what I do:
  

```{r, echo = TRUE }
subsample <- readRDS('sample_dat.rds') 
```


load relevant libraries: 

```{r, warning = FALSE, message= FALSE}

library(tidyverse)
library(lubridate)
library(data.table)
library(phenofit)

```


First, I define phenofit parameters and thresholds. I don't think that there is anything, which is cleary wrong here?

```{r, echo = TRUE}
nptperyear      <- 365              # 365, number of points per year
wmin            <- 0.01             # 0.01, the minimum weight of bad points 
rtrough_max     <- 0.02             # 0.02, highest possible value for local minima
ypeak_min       <- 3                # 3cm, min growth that the peak is still recognized
MaxPeaksPerYear <- 1                # 1, how many peaks per year should be found? Only one
maxExtendMonth <- 1                 # 1, Search good or marginal good values in previous and subsequent maxExtendMonth period.
minExtendMonth <- 0.5               # 0.5, Extend period defined by nextend and maxExtendMonth
minPercValid   <- 0                 # 0
wFUN           <- "wBisquare"       # "wBisquare",  bisquare is the most robust!
rFUN           <- "smooth_wWHIT"    # "smooth_wWHIT", rough curve fitting function
methods_fine   <- "Elmore"          # "Elmore" - function


TRS <- c(0.1, 0.2, 0.5)
```



I continue with pre-processing: growing season division:

```{r echo=TRUE}
### PREPROCESSING
INPUT <- check_input(t = subsample$date,           # Date variable
                     y = subsample$HS_plants,      # vegetation index
                     nptperyear = nptperyear,      # points per year (365)
                     wmin = wmin)                  # the minimum weight of bad points 

### GROWING SEASON DIVISION
brks <- season_mov(INPUT,
                   list(
                     rFUN = rFUN, 
                     wFUN = wFUN,
                     maxExtendMonth = maxExtendMonth,
                     wmin = wmin,
                     rtrough_max = rtrough_max, 
                     ypeak_min = ypeak_min,     
                     MaxPeaksPerYear = MaxPeaksPerYear))

```


here, the season division plot:

```{r echo=TRUE}
plot_season(INPUT, brks,
            ylab = "Plant Height",
            title = paste0(distinct(subsample, station_id), " Season"),
            show.legend = T) 

```

And here the fine curve fitting:
```{r echo = TRUE}
fit <- curvefits(INPUT, brks,
                 list(
                   methods = "Elmore", 
                   wFUN = wFUN,
                   iters = 2,
                   wmin = wmin,
                   nextend = 2,
                   maxExtendMonth = maxExtendMonth, 
                   minExtendMonth = minExtendMonth,
                   minPercValid = minPercValid
                 ))
```


I extract the parameters: 

```{r}

### getting phenological parameters:
pheno_param <- get_pheno(fit, TRS= TRS, method = "Elmore", IsPlot = T)

# getting elmore curve parameters:
elm_param <- get_param(fit)

```

I merge all the parameters into one tibble.

```{r}
all_params <- pheno_param$doy %>% 
  melt_list("meth") %>%  
  mutate(station_id = unique(subsample$station_id),
         year = lubridate::year(origin)) %>% 
  left_join(elm_param$Elmore, by = "flag") %>% 
  left_join(gof_param, by = c("flag", "meth"))
```


### Curve fitting myself
Then, I do the curve fitting myself using the elmore function as defined below. 

```{r}
# define Elmore function
elm_fun <- function(t, mn, mx, sos, rsp, eos, rau, m7) {
  mn + (mx - m7 * t) * (1/(1 + exp(-rsp * (t - sos))) - 1/(1 + exp(-rau * (t - eos))))
}

```
I believe that here could be a source of error. However, according to the package documentation, this is the same parametrization as used in the fine-fitting in `get_pheno(..., isPlot=TRUE)`. I use `DER.sos` and `DER.eos` from `get_pheno()` as inputs for `sos` and `eos`. Is this correct or could this be the problem? The other curve parameters are named the same in the `get_param()` output.


I merge the input data with the phenological parameters and create a plot. I use `mutate(phenofit = elm_fun(..))` to reproduce the phenofit curve in `ggplot()`.

```{r, warning = FALSE}
subsample  %>%
  left_join(all_params, by = c('year', 'station_id')) %>% 
  mutate(phenofit = elm_fun(doy, mn, mx, DER.sos, rsp, DER.eos, rau, m7)) %>% # here I generate the y values based on the parameters
  #filter(year %in% c(2017:2019)) %>% 
  ggplot(.)+
  geom_point(aes(y = HS_plants, x = doy), size = 0.5) + 
  geom_path(aes(x = doy, y = phenofit, colour = "Phenofit"), size = 1)+
  geom_point(aes(y = HS_plants, x = doy, colour = "Plant signal"), size = 1) + 
  geom_point(data = label_points, aes(x = x_values, y = phenofit_y, color = "SOS_points"), size = 5, shape =18)+
  geom_vline(aes(xintercept = DER.sos, color = "SOS"))+
  xlim(100, 340) + 
  ylim (0, 80) +
  labs( y = "Plant Height [cm] ", x = "DOY") + 
  scale_color_manual(name = element_blank(), values = c("Plant signal" = "darkgreen",
                                                        "Phenofit"  = "darkred",
                                                        "SOS" = "purple"))+
  facet_wrap(~year, ncol = 1)
```


And comparing this with the `get_pheno()` output, we can see that the curves are different from phenofits curves! And most importantly, the points for the start of season (derivative method) are also not matching the input points.  
```{r, results = 'hide'}
### compare with get_pheno()
get_pheno(fit, TRS= TRS, method = "Elmore", IsPlot = T)

```

Note also, that the `mx` parameter from `get_param(fit)` are higher than the output above generated by `get_pheno()`. However, this explains why the parametrized curves by myself look the way they look -- higher!

```{r, echo = FALSE}
kbl(elm_param$Elmore) %>% kable_styling(full_width = TRUE) %>% column_spec(3, color = "red")
```
<br>

So my question is: **Can someone explain to me why there is this deviation between get_pheno() and the curves when parametrized by the curve parameters? Or asked in another way: how are the curves in getpheno(isPlot=TRUE) generated?** And how do I extract the exact same DER.sos points from getpheno(isPlot=TRUE) as well as the growth curves generated by it?



